<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plataforma 3D - Aventura Épica</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #1a1a2e; cursor: grab; }
        body.grabbing { cursor: grabbing; }
        #container { width: 100vw; height: 100vh; display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px; 
            padding: 8px;
            background-color: rgba(10, 10, 20, 0.7);
            border-radius: 12px;
            border: 2px solid #4a4a8a;
            z-index: 10;
            box-shadow: 0 0 15px rgba(74, 74, 138, 0.5);
        }
        .control-button {
            font-family: 'Press Start 2P', cursive; 
            background-color: #3c3c76; 
            color: #e0e0ff;
            border: 2px solid #5f5fb6;
            padding: 12px 18px; 
            border-radius: 8px;
            font-size: 12px; 
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 #2a2a52; 
            text-transform: uppercase;
        }
        .control-button:hover {
            background-color: #4a4a8a;
            color: #fff;
            box-shadow: 0 4px 0 #383866;
        }
        .control-button:active {
            background-color: #2a2a52;
            box-shadow: 0 2px 0 #1a1a36;
            transform: translateY(2px); 
        }
        #jump-button-container {
            position: absolute;
            bottom: 20px; 
            right: 20px;
            z-index: 10;
        }
        #jump.control-button {
             padding: 18px 25px; 
        }
        #loading-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 20px;
            color: #e0e0ff;
            background-color: rgba(10, 10, 20, 0.9);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid #4a4a8a;
            z-index: 100;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="loading-message">Carregando Aventura...</div>
    <div id="container"></div>

    <div id="controls">
        <button id="left" class="control-button">Esq</button>
        <button id="forward" class="control-button">Frt</button>
        <button id="backward" class="control-button">Trs</button>
        <button id="right" class="control-button">Dir</button>
    </div>

    <div id="jump-button-container">
        <button id="jump" class="control-button">Pular</button>
    </div>

    <script type="module">
        // Variáveis globais da cena
        let scene, camera, renderer, playerModel, ground;
        let playerVelocity = new THREE.Vector3();
        let playerOnGround = false;
        const playerSpeed = 0.12; 
        const jumpStrength = 0.30;
        const gravity = -0.012;
        const playerHeight = 1.8; 
        const playerRadius = 0.4; 
        const playerHalfHeight = playerHeight / 2; 

        const keysPressed = {
            'w': false, 'a': false, 's': false, 'd': false, ' ': false,
            'arrowup': false, 'arrowleft': false, 'arrowdown': false, 'arrowright': false
        };

        let loadingMessage;
        let environmentObjects = [];
        let rockyPatchTexture; 
        let leafTexture; 
        let torchLight; 

        // Animação do personagem
        let leftLeg, rightLeg, leftArm, rightArm;
        let walkCycleTime = 0;
        const walkCycleSpeed = 0.25; 
        const legSwingAngle = Math.PI / 6; 
        const armSwingAngle = Math.PI / 7; 

        // Pássaros
        let birds = [];
        const clock = new THREE.Clock(); 

        // Dragão
        let dragon;
        let mountainCenter = new THREE.Vector3(); // Centro da montanha para o voo do dragão
        let mountainTopY = 0; // Altura do topo da montanha

        // Controle da Câmera com Mouse
        let isMouseDown = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraYaw = 0; 
        let cameraPitch = 0.3; 
        const cameraDistance = 10; 
        const mouseSensitivity = 0.005;

        function createProceduralTexture(color1, color2, size = 64, pattern = 'checker', density = 100) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const context = canvas.getContext('2d');
            context.fillStyle = color1; 
            context.fillRect(0, 0, size, size);
            context.fillStyle = color2; 

            if (pattern === 'checker') {
                const step = size / 8; 
                for (let i = 0; i < size; i += step) {
                    for (let j = 0; j < size; j += step) {
                        if (((i / step) + (j / step)) % 2 === 0) {
                            context.fillRect(i, j, step, step);
                        }
                    }
                }
            } else if (pattern === 'stripes') {
                const step = size / 16;
                 for (let i = 0; i < size; i += step * 2) {
                    context.fillRect(0, i, size, step);
                }
            } else if (pattern === 'dots') {
                for (let i = 0; i < density; i++) { 
                    context.fillRect(Math.random() * size, Math.random() * size, Math.random() * 3 + 1, Math.random() * 3 + 1);
                }
            } else if (pattern === 'grass') { 
                context.fillStyle = color1; 
                context.fillRect(0,0,size,size);
                for (let i = 0; i < density * 2; i++) { 
                    context.fillStyle = Math.random() > 0.3 ? color2 : shadeColor(color2, -20); 
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const length = Math.random() * (size/10) + (size/20);
                    const angle = (Math.random() - 0.5) * Math.PI / 3; 
                    context.save();
                    context.translate(x,y);
                    context.rotate(angle);
                    context.fillRect(-1, -length/2, 2, length); 
                    context.restore();
                }
            } else if (pattern === 'rock_surface') { 
                 context.fillStyle = color1; 
                 context.fillRect(0,0,size,size);
                 for(let i=0; i < density * 1.5; i++) {
                    context.fillStyle = Math.random() > 0.5 ? color2 : shadeColor(color2, Math.random() > 0.5 ? 10 : -10); 
                    context.beginPath();
                    context.arc(Math.random() * size, Math.random() * size, Math.random() * (size/15) + (size/30), 0, Math.PI*2);
                    context.fill();
                 }
            } else if (pattern === 'leaves_detailed') { 
                context.fillStyle = color1; 
                context.fillRect(0,0,size,size);
                for (let i=0; i < density * 3; i++) { 
                    const leafColor = Math.random() > 0.6 ? color2 : shadeColor(color2, (Math.random() * 40) - 20); 
                    context.fillStyle = leafColor;
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    const leafWidth = Math.random() * (size/12) + (size/20);
                    const leafHeight = Math.random() * (size/8) + (size/16);
                    context.save();
                    context.translate(x,y);
                    context.rotate(Math.random() * Math.PI * 2); 
                    context.beginPath();
                    context.ellipse(0, 0, leafWidth/2, leafHeight/2, 0, 0, Math.PI*2); 
                    context.fill();
                    context.restore();
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.magFilter = THREE.NearestFilter; 
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function shadeColor(color, percent) {
            let R = parseInt(color.substring(1,3),16);
            let G = parseInt(color.substring(3,5),16);
            let B = parseInt(color.substring(5,7),16);
            R = parseInt(R * (100 + percent) / 100); G = parseInt(G * (100 + percent) / 100); B = parseInt(B * (100 + percent) / 100);
            R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255;  
            R = Math.round(R); G = Math.round(G); B = Math.round(B);
            const RR = ((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16));
            const GG = ((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16));
            const BB = ((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
            return "#"+RR+GG+BB;
        }

        function createPlayerModel() {
            const model = new THREE.Group();
            const skinMaterial = new THREE.MeshStandardMaterial({ color: 0xFFDBAC, roughness: 0.8 });
            const hairMaterial = new THREE.MeshStandardMaterial({ color: 0x302010, roughness: 0.7 });
            const shirtMaterial = new THREE.MeshStandardMaterial({ color: 0xAD8E6E, roughness: 0.6 });
            const pantsMaterial = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.7 });
            const hatMaterial = new THREE.MeshStandardMaterial({ color: 0x704214, roughness: 0.5 });

            const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), skinMaterial);
            head.position.y = playerHeight - 0.25; model.add(head);
            const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.45, 0.45, 0.05, 16), hatMaterial);
            hatBrim.position.y = playerHeight - 0.025; model.add(hatBrim);
            const hatTop = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.25, 0.3, 16), hatMaterial);
            hatTop.position.y = playerHeight + 0.125; model.add(hatTop);
            for (let i = 0; i < 8; i++) {
                const dread = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6), hairMaterial);
                const angle = (i / 8) * Math.PI * 2;
                dread.position.set( Math.cos(angle) * 0.2, playerHeight - 0.4, Math.sin(angle) * 0.2 );
                dread.rotation.x = Math.PI / 12 + (Math.random() * Math.PI / 8);
                dread.rotation.z = (Math.random() - 0.5) * Math.PI / 8; model.add(dread);
            }
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.35), shirtMaterial);
            torso.position.y = playerHeight - 0.25 - 0.4 - 0.15; model.add(torso);
            
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            leftArm = new THREE.Mesh(armGeo, shirtMaterial);
            leftArm.position.set(-0.4, torso.position.y, 0); model.add(leftArm);
            rightArm = new THREE.Mesh(armGeo, shirtMaterial);
            rightArm.position.set(0.4, torso.position.y, 0); model.add(rightArm);
            
            const legGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
            leftLeg = new THREE.Mesh(legGeo, pantsMaterial); 
            leftLeg.position.set(-0.15, torso.position.y - 0.4 - 0.35, 0); 
            model.add(leftLeg);
            rightLeg = new THREE.Mesh(legGeo, pantsMaterial); 
            rightLeg.position.set(0.15, torso.position.y - 0.4 - 0.35, 0); 
            model.add(rightLeg);

            const torchGroup = new THREE.Group();
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x5C3317, roughness: 0.8 }); 
            const flameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xFF8C00, emissive: 0xFF4500, emissiveIntensity: 0.8 
            });
            const handleGeometry = new THREE.CylinderGeometry(0.05, 0.06, 0.5, 8);
            const torchHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            torchHandle.position.y = -0.1; torchGroup.add(torchHandle);
            const flameGeometry = new THREE.SphereGeometry(0.1, 8, 6); 
            const torchFlame = new THREE.Mesh(flameGeometry, flameMaterial);
            torchFlame.position.y = 0.25; torchGroup.add(torchFlame);
            torchLight = new THREE.PointLight(0xffaa33, 0.9, 12); 
            torchLight.castShadow = false; 
            torchLight.position.set(0, 0.05, 0); 
            torchFlame.add(torchLight);
            torchGroup.position.set(0.05, 0.2, 0.1); 
            torchGroup.rotation.x = Math.PI / 12; 
            rightArm.add(torchGroup); 

            model.traverse(child => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; }});
            const modelBaseY = torso.position.y - 0.4 - 0.35 - 0.35; 
            model.children.forEach(child => { child.position.y -= modelBaseY; });
            return model;
        }

        function createBird(position = new THREE.Vector3(0, 10, 0)) {
            const birdGroup = new THREE.Group();
            birdGroup.userData = {
                animationTime: Math.random() * 100, flapSpeed: 5 + Math.random() * 3, 
                wanderAngle: Math.random() * Math.PI * 2, wanderSpeed: 0.03 + Math.random() * 0.02, 
                nextWanderChange: 3 + Math.random() * 5, targetY: 8 + Math.random() * 7, 
            };
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: shadeColor('#87CEFA', -20), roughness: 0.7 }); 
            const wingMaterial = new THREE.MeshStandardMaterial({ color: shadeColor('#ADD8E6', -10), roughness: 0.6 }); 
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 6), bodyMaterial);
            body.scale.z = 0.6; birdGroup.add(body);
            const wingShape = new THREE.Shape();
            wingShape.moveTo(0, 0); wingShape.lineTo(0.8, 0.1); wingShape.lineTo(0.7, -0.1); wingShape.lineTo(0, -0.05);
            const wingExtrudeSettings = { depth: 0.05, bevelEnabled: false };
            const wingGeometry = new THREE.ExtrudeGeometry(wingShape, wingExtrudeSettings);
            const birdLeftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            birdLeftWing.position.set(0, 0.05, -0.25); birdLeftWing.rotateY(Math.PI / 2); 
            birdGroup.add(birdLeftWing); birdGroup.userData.leftWing = birdLeftWing;
            const birdRightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            birdRightWing.position.set(0, 0.05, 0.25); birdRightWing.rotateY(-Math.PI / 2);
            birdGroup.add(birdRightWing); birdGroup.userData.rightWing = birdRightWing;
            birdGroup.position.copy(position);
            birdGroup.castShadow = true; 
            birdGroup.traverse(child => { if(child.isMesh) child.castShadow = true; });
            scene.add(birdGroup);
            return birdGroup;
        }

        function createMountain(basePosition, baseRadius, totalHeight, segments) {
            const mountainGroup = new THREE.Group();
            mountainGroup.position.copy(basePosition); // Definir a posição do grupo da montanha
            let currentRadius = baseRadius;
            let currentHeightOffset = 0;
            const segmentHeight = totalHeight / segments;
            const material = new THREE.MeshStandardMaterial({ map: rockyPatchTexture, roughness: 0.9, metalness: 0.1 });

            for (let i = 0; i < segments; i++) {
                const topRadius = Math.max(1, currentRadius * (0.65 + Math.random() * 0.25)); 
                const segmentGeo = new THREE.CylinderGeometry(topRadius, currentRadius, segmentHeight, 12); 
                const segmentMesh = new THREE.Mesh(segmentGeo, material);
                
                segmentMesh.position.set(
                    (Math.random() - 0.5) * currentRadius * 0.15, 
                    currentHeightOffset + segmentHeight / 2,
                    (Math.random() - 0.5) * currentRadius * 0.15  
                );
                segmentMesh.rotation.y = Math.random() * Math.PI; 
                segmentMesh.castShadow = true;
                segmentMesh.receiveShadow = true;
                mountainGroup.add(segmentMesh);
                // Adicionar cada segmento individualmente para colisão se necessário,
                // ou tratar a colisão com o grupo (mais complexo para formas irregulares)
                // Por simplicidade, vamos adicionar ao environmentObjects para colisão.
                // Precisamos transformar a posição do segmento para coordenadas do mundo antes de adicionar.
                const worldSegment = segmentMesh.clone(); // Clonar para não afetar o original no grupo
                worldSegment.position.add(basePosition); // Adicionar a posição base da montanha
                environmentObjects.push(worldSegment); 

                currentRadius = topRadius;
                currentHeightOffset += segmentHeight * 0.85; // Sobrepor um pouco menos para mais altura
            }
            scene.add(mountainGroup);
            // Retornar o centro e o topo para o dragão
            return {group: mountainGroup, center: basePosition.clone(), topY: basePosition.y + currentHeightOffset, topRadius: currentRadius};
        }
        
        function createDragon(position) {
            const dragonGroup = new THREE.Group();
            dragonGroup.userData = {
                flightAngle: Math.random() * Math.PI * 2, // Ângulo inicial do voo
                flightRadius: 45, // Raio do voo ao redor da montanha (ajustado)
                flightSpeed: 0.015, // Velocidade de voo
                verticalBobSpeed: 0.8, // Velocidade da oscilação vertical
                verticalBobAmount: 1.5, // Amplitude da oscilação vertical
            };
            const scale = 1.8; // Fator de escala para o dragão
            const dragonMaterial = new THREE.MeshStandardMaterial({ color: 0x007000, roughness: 0.5, metalness: 0.2 }); // Verde mais vibrante

            const bodyGeo = new THREE.BoxGeometry(2*scale, 1.5*scale, 4*scale); // Corpo maior
            const body = new THREE.Mesh(bodyGeo, dragonMaterial);
            body.position.y = 0.75*scale;
            dragonGroup.add(body);

            const neckGeo = new THREE.CylinderGeometry(0.4*scale, 0.55*scale, 2.2*scale, 8);
            const neck = new THREE.Mesh(neckGeo, dragonMaterial);
            neck.position.set(0, 1.8*scale, -1.8*scale);
            neck.rotation.x = Math.PI / 5;
            dragonGroup.add(neck);

            const headGeo = new THREE.BoxGeometry(0.9*scale, 0.8*scale, 1.4*scale);
            const head = new THREE.Mesh(headGeo, dragonMaterial);
            head.position.set(0, 1.2*scale, -0.6*scale); 
            neck.add(head); 

            let tailSegmentParent = dragonGroup;
            let tailSegmentOffsetY = 0.5*scale;
            let tailSegmentOffsetZ = 2*scale;
            for(let i=0; i<5; i++){ // Mais um segmento na cauda
                const tailSizeFactor = 0.6*scale - i*0.08*scale;
                const tailLengthFactor = 1.5*scale - i*0.15*scale;
                const tailSegmentGeo = new THREE.BoxGeometry(tailSizeFactor, tailSizeFactor, tailLengthFactor);
                const tailSegment = new THREE.Mesh(tailSegmentGeo, dragonMaterial);
                tailSegment.position.set(0, tailSegmentOffsetY - i*0.2*scale, tailSegmentOffsetZ + i*0.9*scale);
                tailSegment.rotation.x = -Math.PI / (10 - i*1.2);
                tailSegmentParent.add(tailSegment);
            }

            const wingGeo = new THREE.BoxGeometry(0.25*scale, 3.5*scale, 2.5*scale); // Asas maiores
            const leftWing = new THREE.Mesh(wingGeo, dragonMaterial);
            leftWing.position.set(-1.2*scale, 1.6*scale, -0.3*scale);
            leftWing.rotation.z = Math.PI / 4.5;
            leftWing.rotation.y = -Math.PI / 10;
            dragonGroup.add(leftWing);
            dragonGroup.userData.leftWing = leftWing;


            const rightWing = new THREE.Mesh(wingGeo, dragonMaterial);
            rightWing.position.set(1.2*scale, 1.6*scale, -0.3*scale);
            rightWing.rotation.z = -Math.PI / 4.5;
            rightWing.rotation.y = Math.PI / 10;
            dragonGroup.add(rightWing);
            dragonGroup.userData.rightWing = rightWing;

            dragonGroup.position.copy(position);
            dragonGroup.traverse(child => { if(child.isMesh) {child.castShadow = true; child.receiveShadow = true;} });
            scene.add(dragonGroup);
            return dragonGroup;
        }


        function init() {
            loadingMessage = document.getElementById('loading-message');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x75a8f0); 
            scene.fog = new THREE.Fog(0x75a8f0, 80, 320); // Neblina ajustada
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); 
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); 
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); 
            directionalLight.position.set(50, 60, 40); 
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 250; 
            directionalLight.shadow.camera.left = -120; directionalLight.shadow.camera.right = 120; 
            directionalLight.shadow.camera.top = 120; directionalLight.shadow.camera.bottom = -120;
            scene.add(directionalLight);

            rockyPatchTexture = createProceduralTexture('#606060', '#708090', 64, 'rock_surface', 80);
            leafTexture = createProceduralTexture('#004d00', '#006400', 128, 'leaves_detailed', 120); 

            const groundSize = 400; // Terreno ainda maior
            const mainGroundTexture = createProceduralTexture('#2E8B57', '#3CB371', 128, 'grass', 150); 
            mainGroundTexture.repeat.set(groundSize/4, groundSize/4); 
            const groundMaterial = new THREE.MeshStandardMaterial({ map: mainGroundTexture, roughness: 0.95, metalness: 0.05 });
            ground = new THREE.Mesh(new THREE.PlaneGeometry(groundSize, groundSize), groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            playerModel = createPlayerModel();
            playerModel.position.y = 0; 
            scene.add(playerModel);

            createEnvironment(groundSize);
            createClouds();

            const mountainData = createMountain(new THREE.Vector3(-groundSize * 0.2, 0, groundSize * 0.1), 40, 65, 10);
            mountainCenter.copy(mountainData.center); // Salvar o centro da montanha
            mountainTopY = mountainData.topY;     // Salvar o topo da montanha
            
            // Posicionar o dragão para voar ao redor da montanha
            dragon = createDragon(new THREE.Vector3(mountainCenter.x, mountainTopY + 15, mountainCenter.z));


            for (let i = 0; i < 15; i++) { 
                const birdX = (Math.random() - 0.5) * groundSize * 0.9; 
                const birdY = 18 + Math.random() * 22; 
                const birdZ = (Math.random() - 0.5) * groundSize * 0.9;
                birds.push(createBird(new THREE.Vector3(birdX, birdY, birdZ)));
            }

            setupEventListeners();
            if (loadingMessage) loadingMessage.style.display = 'none';
            animate();
        }

        function createPlatform(x, yBase, z, width, height, depth) { 
            const platformTexture = createProceduralTexture('#696969', '#808080', 64, 'dots', 70); 
            platformTexture.repeat.set(width/1.5, depth/1.5); 
            const material = new THREE.MeshStandardMaterial({ map: platformTexture, roughness:0.85 });
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, yBase + height / 2, z); 
            platform.castShadow = true; platform.receiveShadow = true;
            scene.add(platform); environmentObjects.push(platform);
        }

        function createEnvironment(mapSize) {
            const numTrees = 90; const numRocks = 110; const numPlatforms = 45; 
            const areaSize = mapSize * 0.49; 
            for (let i = 0; i < numPlatforms; i++) {
                const pWidth = Math.random() * 16 + 8; const pHeight = Math.random() * 14 + 3; 
                const pDepth = Math.random() * 16 + 8; const pX = (Math.random() - 0.5) * areaSize * 1.98;
                const pZ = (Math.random() - 0.5) * areaSize * 1.98; const pYBase = 0; 
                if (Math.sqrt(pX*pX + pZ*pZ) > 25) { createPlatform(pX, pYBase, pZ, pWidth, pHeight, pDepth); } 
                else if (i < 7) { createPlatform(pX/2.2 + (Math.random() > 0.5 ? 12: -12) , pYBase, pZ/2.2 + (Math.random() > 0.5 ? 12: -12), pWidth/1.7, pHeight/2.1+0.5, pDepth/1.7); }
            }
            for (let i = 0; i < numTrees; i++) {
                let x = (Math.random() - 0.5) * areaSize * 1.98; let z = (Math.random() - 0.5) * areaSize * 1.98;
                let yBase = 0;
                const platformCandidate = environmentObjects.find(obj => {
                    if (!obj.geometry.parameters) return false; const params = obj.geometry.parameters;
                    return obj.geometry.type === "BoxGeometry" && Math.abs(x - obj.position.x) < params.width / 2 && Math.abs(z - obj.position.z) < params.depth / 2;
                });
                if (platformCandidate) { yBase = platformCandidate.position.y + platformCandidate.geometry.parameters.height / 2; }
                // Evitar árvores muito perto da base da montanha
                if (Math.sqrt(Math.pow(x - mountainCenter.x, 2) + Math.pow(z - mountainCenter.z, 2)) > 50) {
                     if (Math.sqrt(x*x + z*z) > 12) createTree(x, yBase, z);
                }
            }
            for (let i = 0; i < numRocks; i++) {
                 let x = (Math.random() - 0.5) * areaSize * 1.98; let z = (Math.random() - 0.5) * areaSize * 1.98;
                let yBase = 0;
                const platformCandidate = environmentObjects.find(obj => {
                     if (!obj.geometry.parameters) return false; const params = obj.geometry.parameters;
                     return obj.geometry.type === "BoxGeometry" && Math.abs(x - obj.position.x) < params.width / 2 && Math.abs(z - obj.position.z) < params.depth / 2;
                });
                 if (platformCandidate) { yBase = platformCandidate.position.y + platformCandidate.geometry.parameters.height / 2; }
                 if (Math.sqrt(Math.pow(x - mountainCenter.x, 2) + Math.pow(z - mountainCenter.z, 2)) > 45) {
                    if (Math.sqrt(x*x + z*z) > 9) createRock(x, yBase, z);
                 }
            }
        }

        function createTree(x, yBase, z) { 
            const trunkHeight = Math.random() * 4 + 4; const trunkSize = 0.9; 
            const leavesSize = 4; const leavesHeight = 4;
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x7A5230, roughness: 0.9 });
            const trunk = new THREE.Mesh(new THREE.BoxGeometry(trunkSize, trunkHeight, trunkSize), trunkMaterial);
            trunk.position.set(x, yBase + trunkHeight / 2, z);
            trunk.castShadow = true; trunk.receiveShadow = true;
            scene.add(trunk); environmentObjects.push(trunk);
            const leavesMaterial = new THREE.MeshStandardMaterial({ map: leafTexture, roughness: 0.85, metalness: 0.05 });
            const leaves = new THREE.Mesh(new THREE.BoxGeometry(leavesSize, leavesHeight, leavesSize), leavesMaterial);
            leaves.position.set(x, yBase + trunkHeight + leavesHeight / 2 - 0.3, z);
            leaves.castShadow = true; leaves.receiveShadow = true;
            scene.add(leaves); environmentObjects.push(leaves);
        }

        function createRock(x, yBase, z) { 
            const rockSize = Math.random() * 2 + 0.8; 
            const rockMaterial = new THREE.MeshStandardMaterial({ color: 0x708090, roughness: 0.75 });
            const rockGeo = new THREE.BoxGeometry(rockSize, rockSize, rockSize);
            rockGeo.rotateX(Math.random() * Math.PI); rockGeo.rotateY(Math.random() * Math.PI);
            const rock = new THREE.Mesh(rockGeo, rockMaterial);
            rock.position.set(x, yBase + rockSize / 2, z);
            rock.castShadow = true; rock.receiveShadow = true;
            scene.add(rock); environmentObjects.push(rock);
            if (rockyPatchTexture) {
                const patchSize = rockSize * 2.0; 
                const patchGeometry = new THREE.PlaneGeometry(patchSize, patchSize);
                const patchMaterial = new THREE.MeshStandardMaterial({ 
                    map: rockyPatchTexture, transparent: true, opacity: 0.9, roughness: 0.9
                });
                const rockPatch = new THREE.Mesh(patchGeometry, patchMaterial);
                rockPatch.position.set(x, yBase + 0.01, z); 
                rockPatch.rotation.x = -Math.PI / 2; 
                rockPatch.receiveShadow = true; 
                scene.add(rockPatch);
            }
        }

        function createClouds() {
            const numClouds = 80; 
            const cloudMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.60, roughness: 0.95 }); 
            for (let i = 0; i < numClouds; i++) {
                const cloudGroup = new THREE.Group(); const numPuffs = Math.floor(Math.random() * 9) + 6; 
                for (let j = 0; j < numPuffs; j++) {
                    const puffSize = Math.random() * 7 + 4; const puffGeo = new THREE.SphereGeometry(puffSize, 8, 6); 
                    const puff = new THREE.Mesh(puffGeo, cloudMaterial);
                    puff.position.set( (Math.random() - 0.5) * puffSize * 2, (Math.random() - 0.5) * puffSize * 1, (Math.random() - 0.5) * puffSize * 2 );
                    puff.castShadow = true; cloudGroup.add(puff);
                }
                cloudGroup.position.set( (Math.random() - 0.5) * 350, Math.random() * 40 + 40, (Math.random() - 0.5) * 350 ); 
                scene.add(cloudGroup);
            }
        }

        function onMouseDown(event) {
            isMouseDown = true;
            document.body.classList.add('grabbing');
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        function onMouseUp(event) {
            isMouseDown = false;
            document.body.classList.remove('grabbing');
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;
            const deltaX = event.clientX - previousMouseX;
            const deltaY = event.clientY - previousMouseY;
            cameraYaw -= deltaX * mouseSensitivity;
            cameraPitch -= deltaY * mouseSensitivity;
            cameraPitch = Math.max(-Math.PI / 2.2, Math.min(Math.PI / 2.2, cameraPitch));
            previousMouseX = event.clientX;
            previousMouseY = event.clientY;
        }

        function setupEventListeners() {
            document.addEventListener('keydown', (event) => {
                const key = event.key.toLowerCase();
                if (keysPressed.hasOwnProperty(key)) keysPressed[key] = true; if (key === ' ') event.preventDefault();
            });
            document.addEventListener('keyup', (event) => {
                const key = event.key.toLowerCase();
                if (keysPressed.hasOwnProperty(key)) keysPressed[key] = false;
            });
            const setupButtonEvents = (buttonId, key) => {
                const button = document.getElementById(buttonId);
                if (button) {
                    button.addEventListener('mousedown', (e) => { e.stopPropagation(); keysPressed[key] = true; }); 
                    button.addEventListener('mouseup', (e) => { e.stopPropagation(); keysPressed[key] = false; });
                    button.addEventListener('mouseleave', (e) => { if(keysPressed[key]) keysPressed[key] = false; }); 
                    button.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); keysPressed[key] = true; }, { passive: false });
                    button.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); keysPressed[key] = false; });
                }
            };
            setupButtonEvents('forward', 'w'); setupButtonEvents('backward', 's');
            setupButtonEvents('left', 'a'); setupButtonEvents('right', 'd');
            setupButtonEvents('jump', ' ');
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false); 
            document.addEventListener('mousemove', onMouseMove, false); 
            window.addEventListener('resize', onWindowResize, false);
        }
        
        function updateBirds(deltaTime) {
            const mapBoundary = ground.geometry.parameters.width / 2 - 25; 
            const wingFlapMaxAngle = Math.PI / 3;
            birds.forEach(bird => {
                const birdData = bird.userData;
                birdData.animationTime += deltaTime;
                const flapAngle = Math.sin(birdData.animationTime * birdData.flapSpeed) * wingFlapMaxAngle;
                if (birdData.leftWing) birdData.leftWing.rotation.z = flapAngle;
                if (birdData.rightWing) birdData.rightWing.rotation.z = -flapAngle;
                birdData.nextWanderChange -= deltaTime;
                if (birdData.nextWanderChange <= 0) {
                    birdData.wanderAngle = Math.random() * Math.PI * 2;
                    birdData.targetY = 15 + Math.random() * 20; 
                    birdData.nextWanderChange = 3 + Math.random() * 5;
                }
                const moveX = Math.cos(birdData.wanderAngle) * birdData.wanderSpeed;
                const moveZ = Math.sin(birdData.wanderAngle) * birdData.wanderSpeed;
                bird.position.x += moveX; bird.position.z += moveZ;
                if (bird.position.y < birdData.targetY) bird.position.y += 0.035;
                else if (bird.position.y > birdData.targetY) bird.position.y -= 0.035;
                bird.rotation.y = Math.atan2(moveX, moveZ) - Math.PI / 2;
                if (Math.abs(bird.position.x) > mapBoundary || Math.abs(bird.position.z) > mapBoundary) {
                    birdData.wanderAngle += Math.PI; 
                    bird.position.x = Math.max(-mapBoundary, Math.min(mapBoundary, bird.position.x));
                    bird.position.z = Math.max(-mapBoundary, Math.min(mapBoundary, bird.position.z));
                }
                bird.position.y = Math.max(12, Math.min(40, bird.position.y)); 
            });
        }

        function updateDragon(deltaTime) {
            if (!dragon) return;

            const data = dragon.userData;
            data.flightAngle += data.flightSpeed; // Atualizar ângulo de voo

            // Calcular nova posição X e Z ao redor do centro da montanha
            const newX = mountainCenter.x + Math.cos(data.flightAngle) * data.flightRadius;
            const newZ = mountainCenter.z + Math.sin(data.flightAngle) * data.flightRadius;
            
            // Calcular nova posição Y com oscilação vertical
            const newY = mountainTopY + 10 + Math.sin(clock.getElapsedTime() * data.verticalBobSpeed) * data.verticalBobAmount;

            // Interpolar para a nova posição para um movimento suave
            dragon.position.lerp(new THREE.Vector3(newX, newY, newZ), 0.05);

            // Fazer o dragão olhar para a direção do movimento (um pouco à frente no círculo)
            const lookAtX = mountainCenter.x + Math.cos(data.flightAngle + 0.1) * data.flightRadius; // Olhar um pouco à frente
            const lookAtZ = mountainCenter.z + Math.sin(data.flightAngle + 0.1) * data.flightRadius;
            dragon.lookAt(lookAtX, newY, lookAtZ);

            // Animação simples de bater de asas (opcional)
            const wingFlapSpeed = 2.5;
            const wingFlapAngle = Math.PI / 8;
            if(dragon.userData.leftWing) dragon.userData.leftWing.rotation.z = Math.PI / 5 + Math.sin(clock.getElapsedTime() * wingFlapSpeed) * wingFlapAngle;
            if(dragon.userData.rightWing) dragon.userData.rightWing.rotation.z = -Math.PI / 5 - Math.sin(clock.getElapsedTime() * wingFlapSpeed) * wingFlapAngle;

        }

        function updateCameraLook() {
            if (!playerModel || !camera) return;
            const targetX = playerModel.position.x + cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch);
            const targetY = playerModel.position.y + playerHalfHeight + cameraDistance * Math.sin(cameraPitch);
            const targetZ = playerModel.position.z + cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch);
            camera.position.lerp(new THREE.Vector3(targetX, targetY, targetZ), 0.2); 
            camera.lookAt(playerModel.position.x, playerModel.position.y + playerHalfHeight * 0.9, playerModel.position.z);
        }

        function updatePlayer() {
            if (!playerModel) return;
            const moveDirection = new THREE.Vector3(); 
            const cameraForward = new THREE.Vector3();
            camera.getWorldDirection(cameraForward);
            cameraForward.y = 0; cameraForward.normalize(); 
            
            const cameraRight = new THREE.Vector3().crossVectors(cameraForward, camera.up).normalize(); 
            
            let isMoving = false;
            if (keysPressed['w'] || keysPressed['arrowup']) { moveDirection.add(cameraForward); isMoving = true; }
            if (keysPressed['s'] || keysPressed['arrowdown']) { moveDirection.sub(cameraForward); isMoving = true; }
            if (keysPressed['a'] || keysPressed['arrowleft']) { moveDirection.sub(cameraRight); isMoving = true; } 
            if (keysPressed['d'] || keysPressed['arrowright']) { moveDirection.add(cameraRight); isMoving = true; } 
            
            const oldPosition = playerModel.position.clone(); 
            if (moveDirection.lengthSq() > 0) {
                moveDirection.normalize();
                playerModel.position.x += moveDirection.x * playerSpeed;
                playerModel.position.z += moveDirection.z * playerSpeed;
                const targetAngle = Math.atan2(moveDirection.x, moveDirection.z);
                const currentAngle = playerModel.rotation.y;
                let angleDiff = targetAngle - currentAngle;
                while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                playerModel.rotation.y += angleDiff * 0.1; 
            }

            if (isMoving && playerOnGround) {
                walkCycleTime += walkCycleSpeed;
                if (leftLeg) leftLeg.rotation.x = Math.sin(walkCycleTime) * legSwingAngle;
                if (rightLeg) rightLeg.rotation.x = Math.cos(walkCycleTime + Math.PI/2) * legSwingAngle; 
                if (leftArm) leftArm.rotation.x = Math.cos(walkCycleTime + Math.PI/2) * armSwingAngle; 
                if (rightArm) rightArm.rotation.x = Math.sin(walkCycleTime) * armSwingAngle;       
            } else {
                walkCycleTime = 0; 
                if (leftLeg) leftLeg.rotation.x = 0;
                if (rightLeg) rightLeg.rotation.x = 0;
                if (leftArm) leftArm.rotation.x = 0;
                if (rightArm) rightArm.rotation.x = 0;
            }

            if (keysPressed[' '] && playerOnGround) { playerVelocity.y = jumpStrength; playerOnGround = false; }
            playerVelocity.y += gravity; playerModel.position.y += playerVelocity.y; 
            playerOnGround = false; let currentHighestSupportY = -Infinity; 
            if (playerModel.position.y <= 0.0) { currentHighestSupportY = Math.max(currentHighestSupportY, 0.0); }
            environmentObjects.forEach(obj => {
                if (!obj.geometry || !obj.geometry.parameters) return; 
                const objParams = obj.geometry.parameters;
                const objMinX = obj.position.x - objParams.width / 2; const objMaxX = obj.position.x + objParams.width / 2;
                const objBottomY = obj.position.y - objParams.height / 2; const objTopY = obj.position.y + objParams.height / 2;   
                const objMinZ = obj.position.z - objParams.depth / 2; const objMaxZ = obj.position.z + objParams.depth / 2;
                const playerFeetY = playerModel.position.y; const playerOldFeetY = oldPosition.y;
                const playerHeadY = playerModel.position.y + playerHeight;
                const playerCenterX = playerModel.position.x; const playerCenterZ = playerModel.position.z;
                const horizontalOverlap = playerCenterX + playerRadius > objMinX && playerCenterX - playerRadius < objMaxX &&
                                          playerCenterZ + playerRadius > objMinZ && playerCenterZ - playerRadius < objMaxZ;
                if (horizontalOverlap) {
                    if (playerOldFeetY >= objTopY && playerFeetY <= objTopY) { currentHighestSupportY = Math.max(currentHighestSupportY, objTopY); }
                    else if (playerHeadY > objBottomY && playerFeetY < objTopY) {
                        playerModel.position.x = oldPosition.x; playerModel.position.z = oldPosition.z;
                    }
                }
            });
            if (currentHighestSupportY > -Infinity && playerModel.position.y <= currentHighestSupportY + 0.001 && playerVelocity.y <=0) { 
                playerModel.position.y = currentHighestSupportY; playerVelocity.y = 0; playerOnGround = true;
            }
        }

        function animate() { 
            requestAnimationFrame(animate); 
            const deltaTime = clock.getDelta(); 
            updatePlayer(); 
            updateBirds(deltaTime); 
            updateDragon(deltaTime); // Adicionar atualização do dragão
            updateCameraLook(); 
            renderer.render(scene, camera); 
        }
        function onWindowResize() {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }
        window.onload = function() {
            if (typeof THREE === 'undefined') {
                console.error("Three.js não carregou.");
                if (loadingMessage) { loadingMessage.textContent = "Erro ao carregar Three.js."; loadingMessage.style.color = "red"; }
                return;
            }
            init();
        };
    </script>
</body>
</html>
